#include "UltraEngine.h"

using namespace UltraEngine;

struct Member
{
	String name;
	String type;
};

struct Argument
{
	String name;
	String type;
	String defaultvalue;
};

class Method
{
public:
	String name;
	std::vector<Argument> arguments;
	String returntype;
};

bool operator<(const Method& m1, const Method& m2)
{
	if (m1.name < m2.name) return true;
	if (m1.name > m2.name) return false;
	if (m1.arguments.size() < m2.arguments.size()) return true;
	if (m1.arguments.size() > m2.arguments.size()) return false;
	for (int n = 0; n < m1.arguments.size(); ++n)
	{
		if (m1.arguments[n].type < m2.arguments[n].type) return true;
		if (m1.arguments[n].type > m2.arguments[n].type) return false;
	}
	return false;
}

struct Class
{
	String dir;
	String name;
	std::vector<Member> members;
};

struct ComponentInfo
{
	String name;
	String path;
};

std::map<Method, std::set<String> > methodclasses;
std::vector<String> components;
std::vector<ComponentInfo> componentinfos;
bool rebuild = false;
uint64_t headertime;

void ProcessDir(WString path)
{
	auto dir = LoadDir("Source/Components/" + path);
	for (WString file : dir)
	{
		auto fullpath = file;
		if (path != "") fullpath = path + "/" + file;
		auto ext = ExtractExt(file).Lower();
		if (FileType("Source/Components/" + fullpath) == 1)
		{
			if (ext == "h" or ext == "hpp")
			{
				if (rebuild == false and FileTime("Source/Components/" + fullpath) > headertime) rebuild = true;
				ComponentInfo info;
				info.name = file.ToString();
				info.path = path.ToString();
				componentinfos.push_back(info);
				components.push_back(info.name);
			}
		}
		else if (FileType("Source/Components/" + fullpath) == 2)
		{
			ProcessDir(fullpath);
		}
	}
}

//This has to be a separate functon or the stack gets too big when sol is initialized
int WriteHeaders()
{
#ifndef _DEBUG
	if (!rebuild)
	{
		Print("All files are up-to-date.");
		return 0;
	}
#endif

	//auto stream = WriteFile("Source/Component System.h");
	auto stream = CreateBufferStream();
	if (stream == NULL)
	{
		Print("Failed ti write file \"Source/ComponentSystem.h\"");
		return 1;
	}

	stream->WriteLine("//-----------------------------------------------------------------------");
	stream->WriteLine("//");
	stream->WriteLine("// This file is generated by the pre-processor. Do not modify it.");
	stream->WriteLine("//");
	stream->WriteLine("//-----------------------------------------------------------------------");
	stream->WriteLine("");

	stream->WriteLine("#pragma once");
	stream->WriteLine("#include \"UltraEngine.h\"");
	stream->WriteLine("");
	stream->WriteLine("using namespace UltraEngine;");
	stream->WriteLine("using namespace std;\n");

	stream->WriteLine("class Component;");
	stream->WriteLine("class Actor;");
	stream->WriteLine("extern bool _LoadComponentState(shared_ptr<Component> component, nlohmann::json & j3);");
	stream->WriteLine("extern bool _SaveComponentState(shared_ptr<Component> component, nlohmann::json & j3);");
	stream->WriteLine("extern shared_ptr<Component> _CopyComponent(shared_ptr<Component> component);");
	stream->WriteLine("extern std::shared_ptr<Actor> GetEntityActor(std::shared_ptr<Entity> entity);");
	//stream->WriteLine("extern bool _CopyComponentState(shared_ptr<Component> c1, shared_ptr<Component> c2);");
	//stream->WriteLine("extern void InitComponentSystem();");
	//stream->WriteLine("extern shared_ptr<Actor> GetEntityActor(shared_ptr<Entity> entity);");
	stream->WriteLine("");

	std::set<String> classeswithupdatemethod;
	std::set<String> classeswithstartmethod;

	std::vector<Class> classes;
	std::set<Method> methods;

	for (auto c : componentinfos)
	{
		bool ispublic = false;
		bool methodsstarted = false;
		//Print("");
		//Print(c);

		Class cclass;
		cclass.name = StripExt(c.name);
		cclass.name = cclass.name.Replace("-", "");
		cclass.name = cclass.name.Replace(" ", "");

		auto fullname = c.name;
		if (c.path != "") fullname = c.path + "/" + c.name;
		auto hs = ReadFile("Source/Components/" + fullname);

		if (hs == NULL) continue;

		while (!hs->EOF())
		{
			auto s = hs->ReadLine().Trim();
			int i = s.Find("//");

			if (i != -1) s = s.Left(i);

			if (s == "public:") ispublic = true;
			if (s == "private:") ispublic = false;
			if (s == "protected:") ispublic = false;

			if (s.Find("(") != -1) methodsstarted = true;

			if (ispublic)
			{
				if (s.Left(7) == "virtual")
				{
					s = s.Right(s.size() - 7).Trim();
					if (s.Left(1) == "~") continue;

					i = s.Find("(");
					auto left = s.Left(i).Trim();
					auto sarr = left.Split("");
					auto right = s.Right(s.size() - i - 1);
					i = right.Find(")");
					right = right.Left(i);

					auto funcname = sarr[sarr.size() - 1].Trim();

					//if (funcname == "Start") continue;					
					if (funcname == "ProcessEvent") continue;
					if (funcname == "LoadState") continue;
					if (funcname == "SaveState") continue;
					//if (funcname == "CopyState") continue;
					if (funcname == "Remove") continue;

					Method m;
					m.name = funcname;

					std::string rt;
					for (int n = 0; n < sarr.size() - 1; ++n)
					{
						rt += sarr[n];
					}
					m.returntype = rt;

					sarr = right.Split(",");

					for (int n = 0; n < sarr.size(); ++n)
					{
						Argument a;

						auto arg = sarr[n].Trim();
						auto sarr3 = arg.Split("=");

						if (sarr3.size() > 1)
						{
							a.defaultvalue = sarr3[sarr3.size() - 1].Trim();
						}

						auto sarr2 = sarr3[0].Split("");

						a.name = sarr2[sarr2.size() - 1];
						for (int k = 0; k < sarr2.size() - 1; ++k)
						{
							if (!a.type.empty()) a.type += " ";
							a.type += sarr2[k];
						}
						m.arguments.push_back(a);
					}

					if (funcname == "Start")
					{
						if (m.arguments.empty()) classeswithstartmethod.insert(cclass.name);
						continue;
					}

					if (funcname == "Update")
					{
						if (m.arguments.empty()) classeswithupdatemethod.insert(cclass.name);
						continue;
					}

					methods.insert(m);
					methodclasses[m].insert(cclass.name);
				}
				else
				{
					if (!ispublic) continue;
					if (methodsstarted) continue;
					if (s.Find(";") == -1) continue;
					s = s.Replace(";", "");

					//This handles default definition in member declaration:
					//int m = 3;
					{
						auto sarr = s.Split("=");
						if (sarr.size() > 1)
						{
							s = sarr[0].Trim();
						}
					}

					Member m;
					vector<String> types = { "WString", "String", "float", "dFloat", "int", "double", "bool", "Vec2", "Vec3", "Vec4", "Mat3", "Mat4", "Plane", "Quat", "dVec2", "dVec3", "dVec4", "dMat3", "dMat4", "dPlane", "dQuat", "iVec2", "iVec3", "iVec4" };

					bool found = false;
					for (auto type : types)
					{
						if (s.Left(type.size()) == type)
						{
							m.type = type;
							s = s.Right(s.size() - type.size() - 1);
							found = true;
							break;
						}
					}

					if (!found)
					{
						int i = s.Find(">");
						if (i > -1)
						{
							m.type = s.Left(i);
							s = s.Right(s.size() - m.type.size() - 1);
							m.type = m.type.Replace(" ", "");
						}
						else
						{
							i = s.Find(" ");
							if (i > -1)
							{
								m.type = s.Left(i);
								s = s.Right(s.size() - m.type.size() - 1);
							}
						}
					}

					if (m.type.Left(5) == "std::") m.type = m.type.Right(m.type.size() - 5);

					auto sarr = s.Split(",");
					for (int n = 0; n < sarr.size(); ++n)
					{
						m.name = sarr[n].Trim();
						cclass.members.push_back(m);
					}

				}
			}
		}
		classes.push_back(cclass);
		hs->Close();
	}

	/*stream->WriteLine("enum SignalID");
	stream->WriteLine("{");
	std::set<String> signals = { "	SIGNALID_COLLISION" };
	for (auto m : methods)
	{
		signals.insert("	SIGNALID_" + m.name.Upper());
	}
	String ss;
	bool started = false;
	for (auto s : signals)// int n = 0; n < signals.size(); ++n)
	{
		if (ss != "") ss += ",\n";
		ss += s;
		if (!started) ss += " = 10001";
		started = true;
		//if (n < signals.size() - 1) signals[n] += ",";
	}
	stream->WriteLine(ss);
	stream->WriteLine("};\n");*/

	std::set<Method> uniquemethods;
	for (auto m : methods)
	{
		m.name = "";
		uniquemethods.insert(m);
	}

	for (auto c : classes)
	{
		stream->WriteLine("class " + c.name + ";");
	}


	stream->WriteLine("\nclass Actor : public ActorBase");
	stream->WriteLine("{");
	//stream->WriteLine("	std::shared_ptr<Entity> m_entity;");

	for (auto c : classes)
	{
		stream->WriteLine("	std::shared_ptr<" + c.name + "> m_" + c.name.Lower() + ";");
	}
	
	int countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		stream->WriteLine("\n	struct ActorMethod" +String(countuniquemethods)+ "Arguments");
		stream->WriteLine("	{");
		int a = 0;
		for (auto arg : m.arguments)
		{
			stream->WriteLine("		" + arg.type.Replace("const","").Replace("&","").Trim() + " arg"+ String(a) + ";");
			a++;
		}
		stream->WriteLine("	};");
		countuniquemethods++;
	}

	stream->WriteLine("\n	struct ActorMethod");
	stream->WriteLine("	{");
	countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		String args;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ", ";
			args += arg.type;
		}
		stream->WriteLine("		"+m.returntype+" (Actor::* method"+String(countuniquemethods)+")("+args+");");
		countuniquemethods++;
	}
	countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		stream->WriteLine("		ActorMethod" + String(countuniquemethods) + "Arguments args" + String(countuniquemethods) +";");
		countuniquemethods++;
	}
	countuniquemethods = 0;
	String nullmethods;
	{
		String s = "\n		ActorMethod()";
		if (!uniquemethods.empty()) s += " :";
		for (auto m : uniquemethods)
		{
			if (countuniquemethods != 0) nullmethods += ",";
			nullmethods += " method" + String(countuniquemethods) + "(NULL)";
			countuniquemethods++;
		}
		stream->WriteLine(s + nullmethods);
	}
	stream->WriteLine("		{}");
	countuniquemethods = 0;
	{
		String s = "\n		void* GetPtr() {";
		for (auto m : uniquemethods)
		{
			s += "\n			if (method" + String(countuniquemethods) + ") return reinterpret_cast<void*&>(method" + String(countuniquemethods) + ");";
			countuniquemethods++;
		}
		s += "\n			return NULL;\n		};";
		stream->WriteLine(s);
	}
	countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		String args;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ", ";
			args += arg.type;
		}
		stream->WriteLine("\n		ActorMethod(" + m.returntype + " (Actor::* m)(" + args + ") ) : "+ nullmethods +" {");
		stream->WriteLine("			method" + String(countuniquemethods) + " = m;");
		stream->WriteLine("		}");
		countuniquemethods++;
	}
	stream->WriteLine("	};\n");

	stream->WriteLine("\n	struct Connection\n\
	{\n\
		ActorMethod m;\n\
		std::function<void()> func;\n\
		std::shared_ptr<Actor> target;\n\
	};");

	//stream->WriteLine("	std::map<SignalID, std::list<::Connection > > connections;");
	stream->WriteLine("	std::map<void*, std::list<Connection > > connections;");

	stream->WriteLine("\nprivate:");
	stream->WriteLine("	virtual void AddComponent(std::shared_ptr<Component> component);");
	stream->WriteLine("\npublic:");
	stream->WriteLine("	virtual bool Update();");

	/*stream->WriteLine("	virtual void Connect(void* ptr, std::function<void()> func)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c;");
	stream->WriteLine("		c.func = func; ");
	//stream->WriteLine("		c.repeat = repeat;");
	stream->WriteLine("		c.method = NULL; ");
	stream->WriteLine("		connections[ptr].push_back(c);");
	stream->WriteLine("	}");
	stream->WriteLine("");

	stream->WriteLine("	virtual void Connect(void* ptr, void (Actor::* outmethod)(), std::shared_ptr<Actor> target)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c;");
	stream->WriteLine("		c.func = NULL; ");
	stream->WriteLine("		c.target = target;");
	stream->WriteLine("		if (c.target == Self()) c.target = NULL;");
	//stream->WriteLine("		c.repeat = repeat;");
	stream->WriteLine("		c.method = outmethod; ");
	stream->WriteLine("		connections[ptr].push_back(c);");
	stream->WriteLine("	}");
	stream->WriteLine("");*/

	stream->WriteLine("	void FireSignal(void* ptr)");
	stream->WriteLine("	{");
	stream->WriteLine("		auto& f = connections[ptr];");
	stream->WriteLine("		auto it = f.begin(); ");
	stream->WriteLine("		while (it != f.end())");
	stream->WriteLine("		{");
	stream->WriteLine("			if ((*it).func != NULL)");
	stream->WriteLine("			{");
	stream->WriteLine("				(*it).func();");
	stream->WriteLine("			}");
	stream->WriteLine("			else");
	stream->WriteLine("			{");
	stream->WriteLine("				auto t = (*it).target;");
	stream->WriteLine("				if (t == NULL) t = As<Actor>();");
	int ii = 0;
	for (auto m : uniquemethods)
	{
		String args;
		int iii = 0;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ", ";
			args += "(*it).m.args"+String(ii)+".arg" + String(iii);
			iii++;
		}
		if (ii == 0)
		{
			stream->WriteLine("				if ((*it).m.method" + String(ii) + " != NULL)");
		}
		else
		{
			stream->WriteLine("				else if ((*it).m.method" + String(ii) + " != NULL)");
		}
		stream->WriteLine("				{");
		stream->WriteLine("					(t.get()->*((*it).m.method"+String(ii)+"))("+args+");");
		stream->WriteLine("				}");
		ii++;
	}
	//stream->WriteLine("				(t.get()->*((*it).method))();");
	stream->WriteLine("			}");
	//stream->WriteLine("			if (!(*it).repeat)");
	//stream->WriteLine("			{");
	//stream->WriteLine("				it = f.erase(it);");
	//stream->WriteLine("				continue; ");
	//stream->WriteLine("			}");
	stream->WriteLine("			++it; ");
	stream->WriteLine("		}");
	stream->WriteLine("	}");

	stream->WriteLine("\npublic:\n");

	stream->WriteLine("	virtual void Connect(ActorMethod inmethod, std::function<void()> func)");
	stream->WriteLine("	{\n\
		Connection c;\n\
		c.func = func;\n\
		connections[inmethod.GetPtr()].push_back(c);\n\
	}\n");
	//stream->WriteLine("	virtual void Connect(ActorMethod inmethod, void (Actor::* outmethod)(), std::shared_ptr<Actor> target = NULL)");
	//stream->WriteLine("	{");
	//stream->WriteLine("		Connect(inmethod.GetPtr(), outmethod, target);");
	//stream->WriteLine("	}");

	ii = 0;
	for (auto m : uniquemethods)
	{
		String args;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ",";
			args += arg.type + " " + arg.name;
		}
		auto args2 = args;
		if (args2 != "") args2 = ", " + args2;
		stream->WriteLine("	virtual void Connect(ActorMethod inmethod, std::shared_ptr<Actor> target, " + m.returntype + "(Actor::* outmethod)(" + args + ")" + args2 +")");
		stream->WriteLine("	{");
		stream->WriteLine("		Connection c;");
		stream->WriteLine("		c.m = outmethod;");
		stream->WriteLine("		c.target = target;");
		int iii = 0;
		for (auto arg : m.arguments)
		{
			stream->WriteLine("		c.m.args" + String(ii) + ".arg" +String(iii)+ " = " + arg.name + ";");
			iii++;
		}
		stream->WriteLine("		connections[inmethod.GetPtr()].push_back(c);");
		stream->WriteLine("	}");
		stream->WriteLine("");
		ii++;
	}

	/*stream->WriteLine("	virtual void Connect(SignalID signalID, std::function<void()> func, const bool repeat = true)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c;");
	stream->WriteLine("		c.func = func; ");
	stream->WriteLine("		c.repeat = repeat;");
	stream->WriteLine("		c.method = NULL; ");
	stream->WriteLine("		connections[signalID].push_back(c);");
	stream->WriteLine("	}");
	stream->WriteLine("");
	stream->WriteLine("	virtual void Connect(SignalID signalID, void (Actor:: * method)(), const bool repeat = true)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c; ");
	stream->WriteLine("		c.func = NULL;");
	stream->WriteLine("		c.repeat = repeat; ");
	stream->WriteLine("		c.method = method;");
	stream->WriteLine("		connections[signalID].push_back(c); ");
	stream->WriteLine("	}");
	stream->WriteLine("");
	stream->WriteLine("	virtual void FireSignal(SignalID signalID)");
	stream->WriteLine("	{");
	stream->WriteLine("		auto& f = connections[signalID];");
	stream->WriteLine("		auto it = f.begin(); ");
	stream->WriteLine("		while (it != f.end())");
	stream->WriteLine("		{");
	stream->WriteLine("			if ((*it).func != NULL)");
	stream->WriteLine("			{");
	stream->WriteLine("				(*it).func();");
	stream->WriteLine("			}");
	stream->WriteLine("			else");
	stream->WriteLine("			{");
	stream->WriteLine("				(this->*((*it).method))();");
	stream->WriteLine("			}");
	stream->WriteLine("			if (!(*it).repeat)");
	stream->WriteLine("			{");
	stream->WriteLine("				it = f.erase(it);");
	stream->WriteLine("				continue; ");
	stream->WriteLine("			}");
	stream->WriteLine("			++it; ");
	stream->WriteLine("		}");
	stream->WriteLine("	}");
	stream->WriteLine("");*/

	//stream->WriteLine("	const std::shared_ptr<Entity>& entity;");
	/*for (auto c : classes)
	{
		stream->WriteLine("	const std::shared_ptr<::" + c.name + ">& " + c.name.Lower() + ";");
	}*/

	stream->WriteLine("");

	//for (auto c : classes)
	//{
	//	stream->WriteLine("	std::shared_ptr<::" + c.name + "> " + c.name + "();");
	//}

	stream->WriteLine("	\n	Actor();");
	stream->WriteLine("	\n	virtual ~Actor();");
	//stream->WriteLine("	Actor(std::shared_ptr<Entity> entity);");

	stream->WriteLine("\n	template <class T>");
	stream->WriteLine("	shared_ptr<T> AddComponent()");
	stream->WriteLine("	{");
	stream->WriteLine("		auto c = std::make_shared<T>();");
	stream->WriteLine("		if (c->As<Component>() == NULL) RuntimeError(\"Class must be derived from Component.\");");
	stream->WriteLine("		AddComponent(c);");
	stream->WriteLine("		return c;");
	stream->WriteLine("	}");

	stream->WriteLine("\n	template <class T>");
	stream->WriteLine("	std::shared_ptr<T> GetComponent()");
	stream->WriteLine("	{");
	stream->WriteLine("		for (auto c : components)\n		{\n			auto o = std::dynamic_pointer_cast<T>(c);\n			if (o) return o;\n		}");
	stream->WriteLine("	}");

	stream->WriteLine("\n	virtual shared_ptr<Actor> Copy();");
	//stream->WriteLine("	virtual void Start();");
	stream->WriteLine("\n	virtual bool LoadState(nlohmann::json& j3);");
	stream->WriteLine("\n	virtual bool SaveState(nlohmann::json& j3);");
	stream->WriteLine("\n	virtual void Free();");
	stream->WriteLine("#ifdef DOUBLE_FLOAT");
	stream->WriteLine("	virtual void Collision(std::shared_ptr<Entity> collidedentity, const dVec3& position, const dVec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial);");
	stream->WriteLine("#else");
	stream->WriteLine("	virtual void Collision(std::shared_ptr<Entity> collidedentity, const Vec3& position, const Vec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial);");
	stream->WriteLine("#endif");

	for (auto c : methods)
	{
		String def;
		if (c.returntype == "bool") def = " = false";
		else if (c.returntype == "int") def = " = 0";
		else if (c.returntype == "float") def = " = 0.0f";
		else if (c.returntype == "double") def = " = 0.0";
		else if (c.returntype.Left(11) == "shared_ptr<") def = " = NULL";

		String args;
		String s = "	virtual " + c.returntype + " " + c.name + "(";
		for (auto arg : c.arguments)
		{
			if (!args.empty()) args = args + ", ";
			args += arg.type + " " + arg.name;
			if (arg.defaultvalue != "") args = args + " = " + arg.defaultvalue;
		}
		s += args + ");";

		stream->WriteLine(s);
	}

	stream->WriteLine("	friend std::shared_ptr<Actor> CreateActor(std::shared_ptr<Entity>);");
	stream->WriteLine("};");
	stream->WriteLine("");

	stream->WriteLine("class FinalActorFactory : public UltraCore::ActorFactory {");
	stream->WriteLine("	public:");
	stream->WriteLine("	shared_ptr<ActorBase> CreateActor()");
	stream->WriteLine("	{");
	stream->WriteLine("		return make_shared<Actor>();");
	stream->WriteLine("	}");
	stream->WriteLine("};\n");

	stream->WriteLine("inline int InitializeComponentSystem() {");
	stream->WriteLine("	UltraCore::systemactorfactory = new FinalActorFactory;");
	stream->WriteLine("	return 0;");
	stream->WriteLine("}\n");
	stream->WriteLine("inline int _init = InitializeComponentSystem();\n");

	//auto stream2 = WriteFile("Source/Component System.cpp");
	auto stream2 = CreateBufferStream();
	//if (stream2 == NULL)
	//{
	//	Print("Error: Failed to write file \"Source/Component System.cpp\".");
	//	return 1;
	//}

	stream2->WriteLine("//-----------------------------------------------------------------------");
	stream2->WriteLine("//");
	stream2->WriteLine("// This file is generated by the pre-processor. Do not modify it.");
	stream2->WriteLine("//");
	stream2->WriteLine("//-----------------------------------------------------------------------");
	stream2->WriteLine("");

	stream2->WriteLine("#include \"UltraEngine.h\"");
	stream2->WriteLine("#include \"ComponentSystem.h\"");
	stream2->WriteLine("");
	stream2->WriteLine("using namespace UltraEngine;");
	stream2->WriteLine("using namespace std;");
	stream2->WriteLine("");
	//stream2->WriteLine("shared_ptr<Actor> GetEntityActor(shared_ptr<Entity> entity) { return entity->actor->As<Actor>();}");

	stream2->WriteLine("std::shared_ptr<Actor> GetEntityActor(std::shared_ptr<Entity> entity)");
	stream2->WriteLine("{");
	stream2->WriteLine("	if (entity == NULL) RuntimeError(\"Entity must not be NULL\");");
	stream2->WriteLine("	return std::dynamic_pointer_cast<Actor>(entity->actor.lock());");
	stream2->WriteLine("}");
	stream2->WriteLine("");

	stream2->WriteLine("Component::Component()");
	//stream2->WriteLine("Component::Component() : entity(m_entity)");
	stream2->WriteLine("{}");

	//stream2->WriteLine("\nvoid Component::Start()");
	//stream2->WriteLine("{}");

	stream2->WriteLine("\nvoid Component::Update()");
	stream2->WriteLine("{}");

	String defaults;// = " : entity(m_entity)";
	/*for (auto c : classes)
	{
		if (defaults == "") defaults += " :\n"; else defaults += ",\n";
		defaults += c.name.Lower() + "(m_" + c.name.Lower() + ")";
	}*/

	stream2->WriteLine("\nActor::Actor()" + defaults);
	stream2->WriteLine("{}");

	stream2->WriteLine("\nActor::~Actor()" + defaults);
	stream2->WriteLine("{");
	for (auto c : classes)
	{
		stream2->WriteLine("	if (m_" + c.name.Lower() + ") m_" + c.name.Lower() + "->actor = NULL;");
	}
	stream2->WriteLine("}");

	// Actor::Load implementation
	stream2->WriteLine("\nbool Actor::LoadState(nlohmann::json & j3) \n\
{\n\
	if (j3[\"components\"].is_array())\n\
	{\n\
		for (auto& info : j3[\"components\"])\n\
		{\n\
			shared_ptr<Component> c;\n\
			if (!info[\"class\"].is_string()) continue;");
	for (auto c : classes)
	{
		stream2->WriteLine("			if (info[\"class\"] == \"" + c.name + "\") c = std::make_shared<::" + c.name + ">();");
	}
	stream2->WriteLine("			if (c == NULL) continue;");
	stream2->WriteLine("			if (!_LoadComponentState(c, info)) return false;");
	stream2->WriteLine("			AddComponent(c);");
	stream2->WriteLine("		}\n\
	}\n\
	return true;\n\
}");

	stream2->WriteLine("\nbool Actor::SaveState(nlohmann::json& j3)");
	stream2->WriteLine("{");
	stream2->WriteLine("	j3[\"components\"] = nlohmann::json::array();");
	for (auto c : classes)
	{
		stream2->WriteLine("	if (m_" + c.name.Lower() + ")");
		stream2->WriteLine("	{");
		stream2->WriteLine("		nlohmann::json info = nlohmann::json::object();");
		stream2->WriteLine("		if (!m_" + c.name.Lower() + "->SaveState(info)) return false;");
		stream2->WriteLine("		info[\"class\"] = \"" + c.name + "\";");
		stream2->WriteLine("		j3[\"components\"].push_back(info);");
		stream2->WriteLine("	}");
	}
	stream2->WriteLine("	return true;");
	stream2->WriteLine("}");

	stream2->WriteLine("\n#ifdef DOUBLE_FLOAT");
	stream2->WriteLine("void Actor::Collision(std::shared_ptr<Entity> collidedentity, const dVec3& position, const dVec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial)");
	stream2->WriteLine("#else");
	stream2->WriteLine("void Actor::Collision(std::shared_ptr<Entity> collidedentity, const Vec3& position, const Vec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial)");
	stream2->WriteLine("#endif");
	stream2->WriteLine("{");
	stream2->WriteLine("	ActorBase::Start();");
	stream2->WriteLine("	auto actorbase = collidedentity->actor.lock();");
	stream2->WriteLine("	std::shared_ptr<Actor> actor;");
	stream2->WriteLine("	if (actorbase) actor = actorbase->As<Actor>();");
	stream2->WriteLine("	if (actor == NULL) actor = CreateActor(collidedentity);");
	for (auto c : classes)
	{
		stream2->WriteLine("	if (this->m_" + c.name.Lower() + ") this->m_" + c.name.Lower() + "->Collision(actor,position,normal,speed);");
	}
	/*
	stream2->WriteLine("#ifdef DOUBLE_FLOAT");
	stream2->WriteLine("void(Actor::* methodptr)(shared_ptr<Actor>, const dVec3&, const dVec3&, const dFloat, shared_ptr<Material>) = &Actor::Collision;");
	stream2->WriteLine("#else");
	stream2->WriteLine("void(Actor::* methodptr)(shared_ptr<Actor>, const Vec3&, const Vec3&, const dFloat, shared_ptr<Material>) = &Actor::Collision;");
	stream2->WriteLine("#endif");
	stream2->WriteLine("FireSignal(reinterpret_cast<void*&>(methodptr));");
	//stream2->WriteLine("	FireSignal(SIGNALID_COLLISION);");
	stream2->WriteLine("}");*/

	/*stream2->WriteLine("\nvoid Actor::Start()");
	stream2->WriteLine("{");
	for (auto c : classeswithstartmethod)
	{
		stream2->WriteLine("	if (this->" + c.Lower() + ") this->" + c.Lower() + "->Start();");
	}*/
	stream2->WriteLine("}");

	stream2->WriteLine("\nvoid Actor::Free()");
	stream2->WriteLine("{");
	stream2->WriteLine("	connections.clear();");
	stream2->WriteLine("	m_entity = NULL;");
	stream2->WriteLine("}");

	stream2->WriteLine("\nbool Actor::Update()");
	stream2->WriteLine("{");
	stream2->WriteLine("	ActorBase::Start();");
	stream2->WriteLine("	bool succ = false;");
	for (auto c : classeswithupdatemethod)
	{
		stream2->WriteLine("	if (this->m_" + c.Lower() + ")");
		stream2->WriteLine("	{");
		stream2->WriteLine("		this->m_" + c.Lower() + "->Update(); ");
		stream2->WriteLine("		succ = true;");
		stream2->WriteLine("	}");
	}
	stream2->WriteLine("	return succ;");
	stream2->WriteLine("}");

	stream2->WriteLine("\nshared_ptr<Actor> Actor::Copy()");
	stream2->WriteLine("{");
	stream2->WriteLine("	shared_ptr<Entity> e;");
	stream2->WriteLine("	if (this->entity) e = this->entity->Instantiate();");
	stream2->WriteLine("	if (e) e->ResetUpdateHook();");
	stream2->WriteLine("	shared_ptr<Actor> copy = CreateActor(e);");
	stream2->WriteLine("	if (e) e->actor = copy;");
	for (auto c : classes)
	{
		//stream2->WriteLine("	{");
		stream2->WriteLine("		if (this->m_" + c.name.Lower() + ")");
		stream2->WriteLine("		{");
		stream2->WriteLine("			auto o = this->m_" + c.name.Lower() + "->Copy();");
		stream2->WriteLine("			auto oo = o->As<::" + c.name + ">();");
		stream2->WriteLine("			copy->AddComponent(oo);");
		//stream2->WriteLine("			oo->m_entity = e;");
		//stream2->WriteLine("			oo->actor = copy;");
		//stream2->WriteLine("			copy->m_" + c.name.Lower() + " = oo;");
		stream2->WriteLine("		}");
		//stream2->WriteLine("	}");
	}
	//stream2->WriteLine("// NO BAD!!!	copy->connections = this->connections;");
	//stream2->WriteLine("	if (callstart) copy->Start();");
	stream2->WriteLine("	return copy;");
	stream2->WriteLine("}\n");

	stream2->WriteLine("std::shared_ptr<Actor> CreateActor(std::shared_ptr<Entity> e)");
	stream2->WriteLine("{");
	stream2->WriteLine("	auto a = std::make_shared<Actor>();");
	stream2->WriteLine("	a->m_entity = e;");
	stream2->WriteLine("	if (e) e->actor = a;");
	stream2->WriteLine("	return a;");
	stream2->WriteLine("}\n");

	stream2->WriteLine("void Actor::AddComponent(std::shared_ptr<Component> c)");
	stream2->WriteLine("{");
	stream2->WriteLine("	if (c == NULL) RuntimeError(\"Component is NULL\");");
	stream2->WriteLine("	if (entity) entity->ResetUpdateHook();");
	//stream2->WriteLine("	c->m_entity = this->entity;");
	stream2->WriteLine("	c->entity = this->entity;");
//	stream2->WriteLine("	c->actor = this->As<Actor>();");
	stream2->WriteLine("	c->actor = this;");

	for (auto c : classes)
	{
		stream2->WriteLine("	{");
		stream2->WriteLine("		auto o = c->As<::" + c.name + ">();");
		stream2->WriteLine("		if (o) this->m_" + c.name.Lower() + " = o;");
		stream2->WriteLine("	}");
	}
	stream2->WriteLine("	ActorBase::AddComponent(c);");
	//stream2->WriteLine("	if (callstart) c->Start();");
	stream2->WriteLine("}\n");

	/*for (auto c : classes)
	{
		stream2->WriteLine("std::shared_ptr<::" + c.name + "> Actor::" + c.name + "()");
		stream2->WriteLine("{");
		stream2->WriteLine("	if (m_" + c.name.Lower() + ") return m_" + c.name.Lower() + ";");
		stream2->WriteLine("	m_" + c.name.Lower() + " = make_shared<::" + c.name + ">();");
		//		stream2->WriteLine("	m_" + c.name.Lower() + "->Start();");
		stream2->WriteLine("	AddComponent(m_" + c.name.Lower() + ");");
		stream2->WriteLine("	return m_" + c.name.Lower() + ";");
		stream2->WriteLine("}\n");
	}*/

	for (auto c : methods)
	{
		String def;
		if (c.returntype == "bool") def = " = false";
		else if (c.returntype == "int") def = " = 0";
		else if (c.returntype == "float") def = " = 0.0f";
		else if (c.returntype == "double") def = " = 0.0";
		else if (c.returntype.Left(11) == "shared_ptr<") def = " = NULL";

		String args;
		String s = "" + c.returntype + " Actor::" + c.name + "(";
		for (auto arg : c.arguments)
		{
			if (!args.empty()) args = args + ", ";
			args += arg.type + " " + arg.name;
			if (arg.defaultvalue != "") args = args + " = " + arg.defaultvalue;
		}
		s += args + ")";

		stream2->WriteLine(s);

		stream2->WriteLine("{");
		if (c.returntype != "void") stream2->WriteLine("	" + c.returntype + " result" + def + ";");

		stream2->WriteLine("	ActorBase::Start();");

		for (auto cs : methodclasses[c])
		{
			//stream2->WriteLine("		auto c = component->As<" + cs + ">();");
			stream2->WriteLine("	if (this->m_" + cs.Lower() + " != NULL)");
			stream2->WriteLine("	{");
			args = "";
			for (auto arg : c.arguments)
			{
				if (!args.empty()) args = args + ", ";
				args += arg.name;
			}
			auto ss = "this->m_" + cs.Lower() + "->" + c.name + "(" + args + ");";
			if (c.returntype != "void") ss = "result = " + ss;
			stream2->WriteLine("		" + ss);
			if (c.returntype != "void") stream2->WriteLine("		return result;");
			stream2->WriteLine("	}");
		}

		/*
		String desc = c.returntype + "(Actor:: * methodptr)(";
		args = "";
		for (auto a : c.arguments)
		{
			if (args != "") args += ", ";
			args += a.type;
		}
		desc += args + ")";
		stream2->WriteLine("	" + desc + " = &Actor::" + c.name + ";");
		stream2->WriteLine("	FireSignal(reinterpret_cast<void*&>(methodptr));");
		//stream2->WriteLine("	FireSignal(SIGNALID_" + c.name.Upper() + ");");
		if (c.returntype != "void") stream2->WriteLine("	return result;");*/
		stream2->WriteLine("}");
		
		stream2->WriteLine("");
	}

	/*
	stream2->WriteLine("bool SceneLoader::LoadActor(shared_ptr<Entity> entity, nlohmann::json & j3)");
	stream2->WriteLine("{");
	stream2->WriteLine("	if (j3.is_object())");
	stream2->WriteLine("	{");
	stream2->WriteLine("		if (j3[\"components\"].is_array() && j3[\"components\"].empty() == false)");
	stream2->WriteLine("		{");
	stream2->WriteLine("			auto actor = CreateActor(entity);");
	stream2->WriteLine("			if (!actor->LoadState(j3)) return false;");
	stream2->WriteLine("			actors.push_back(actor);");
	stream2->WriteLine("		}");
	stream2->WriteLine("	}");
	stream2->WriteLine("	return Scene::LoadActor(entity, j3);");
	stream2->WriteLine("}");
	stream2->WriteLine("");
	stream2->WriteLine("shared_ptr<SceneLoader> LoadSceneEx(shared_ptr<World> world, const WString & path, const LoadFlags flags)");
	stream2->WriteLine("{");
	stream2->WriteLine("	auto stream = ReadFile(path);");
	stream2->WriteLine("	if (stream == NULL) return NULL;");
	stream2->WriteLine("	auto binstream = ReadFile(StripExt(path) + L\".bin\");");
	stream2->WriteLine("	auto scene = make_shared<SceneLoader>();");
	stream2->WriteLine("	auto j3 = LoadJSON(stream);");
	stream2->WriteLine("	if (!j3.is_object()) return NULL;");
	stream2->WriteLine("	if (!scene->Load(world, j3, binstream, flags)) return NULL;");
	stream2->WriteLine("	return scene;");
	stream2->WriteLine("}\n");

	stream->WriteLine("class SceneLoader : public Scene");
	stream->WriteLine("{");
	stream->WriteLine("	virtual bool LoadActor(shared_ptr<Entity> entity, nlohmann::json& j3);");
	stream->WriteLine("public:");
	stream->WriteLine("	std::vector<std::shared_ptr<Actor> > actors;");
	stream->WriteLine("};");
	stream->WriteLine("");
	stream->WriteLine("#define LoadScene LoadSceneEx");
	stream->WriteLine("");
	stream->WriteLine("extern shared_ptr<SceneLoader> LoadSceneEx(shared_ptr<World> world, const WString & path, const LoadFlags flags = LOAD_DEFAULT);");
	*/
	stream->WriteLine("extern std::shared_ptr<Actor> CreateActor(std::shared_ptr<Entity> entity = NULL);\n");

	stream->WriteLine("class Component : public ComponentBase");
	stream->WriteLine("{");
	//stream->WriteLine("	std::shared_ptr<Entity> m_entity;");
	stream->WriteLine("public:");
	stream->WriteLine("\n	std::shared_ptr<Entity> entity;");
	//stream->WriteLine("\n	std::weak_ptr<Actor> actor;");
	stream->WriteLine("\n	Actor* actor;");
	//stream->WriteLine("	const std::shared_ptr<Entity>& entity;\n");
	stream->WriteLine("	Component();\n");

	stream->WriteLine("#ifdef DOUBLE_FLOAT");
	stream->WriteLine("	virtual void Collision(shared_ptr<Actor> collidedactor, const dVec3& position, const dVec3& normal, const dFloat speed) {}");
	stream->WriteLine("#else");
	stream->WriteLine("	virtual void Collision(shared_ptr<Actor> collidedactor, const Vec3& position, const Vec3& normal, const dFloat speed) {}");
	stream->WriteLine("#endif");

	//stream->WriteLine("	virtual void Start();");
	stream->WriteLine("	virtual void Update();");

	stream->WriteLine("	virtual bool LoadState(nlohmann::json& j3)");
	stream->WriteLine("	{");
	stream->WriteLine("		return _LoadComponentState(As<Component>(), j3);");
	stream->WriteLine("	}");

	stream->WriteLine("\n	virtual bool SaveState(nlohmann::json& j3)");
	stream->WriteLine("	{");
	stream->WriteLine("		return _SaveComponentState(As<Component>(), j3);");
	stream->WriteLine("	}");

	//stream->WriteLine("\n	virtual std::shared_ptr<Actor> GetActor()");
	//stream->WriteLine("	{");
	//stream->WriteLine("		return std::dynamic_pointer_cast<Actor>(this->actor.lock());");
	//stream->WriteLine("	}");

	stream->WriteLine("\n	virtual shared_ptr<Component> Copy()");
	stream->WriteLine("	{");
	stream->WriteLine("		auto c = _CopyComponent(As<Component>());");
	stream->WriteLine("		if (c == NULL) return NULL;");
	//stream->WriteLine("		if (!CopyState(c)) return NULL;");
	stream->WriteLine("		return c;");
	stream->WriteLine("	}");

	//stream->WriteLine("\n	virtual bool CopyState(shared_ptr<Component> c)");
	//stream->WriteLine("	{");
	//stream->WriteLine("		if (!_CopyComponentState(As<Component>(), c->As<Component>())) return false;");
	//stream->WriteLine("		return true;//Component::CopyState(c);");
	//stream->WriteLine("	}");
	stream->WriteLine("	\n	friend Actor;");
	stream->WriteLine("};\n");

	for (auto ci : componentinfos)
	{
		if (ci.path != "") ci.path += "/";
		stream->WriteLine("#include \"Components/" + ci.path + ci.name + "\"");
	}

	//bool succ = SetFileMode("Source/ComponentSystem.h", 33206);

	if (!stream->data->Save("Source/ComponentSystem.h"))
	{
		Print("Error: Failed to write file \"Source/ComponentSystem.h\"");
		return 1;
	}

	//SetFileMode("Source/ComponentSystem.h", 4);

	stream = stream2;

	stream->WriteLine("bool _SaveComponentState(shared_ptr<Component> component, nlohmann::json& j3)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		if (c.members.empty()) continue;

		stream->WriteLine("	{");
		stream->WriteLine("		auto c = component->As<::" + c.name + ">();");
		stream->WriteLine("		if (c) {");

		for (auto m : c.members)
		{
			if (m.type == "Vec2" or m.type == "dVec2" or m.type == "iVec2")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { c->" + m.name + ".x, c->" + m.name + ".y };");
			}
			else if (m.type == "Vec3" or m.type == "dVec3" or m.type == "iVec3")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { c->" + m.name + ".x, c->" + m.name + ".y, c->" + m.name + ".z };");
			}
			else if (m.type == "Vec4" or m.type == "dVec4" or m.type == "iVec4")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { c->" + m.name + ".x, c->" + m.name + ".y, c->" + m.name + ".z, c->" + m.name + ".w };");
			}
			else if (m.type == "shared_ptr<Entity>")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { this->m_" + m.name + "->GETGUID();");
			}
			else if (m.type == "bool" or m.type == "int" or m.type == "float" or m.type == "double" or m.type == "String" or m.type == "std::string" or m.type == "wstring" or m.type == "dFloat")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = c->" + m.name + ";");
			}
			else if (m.type == "WString" or m.type == "String")
			{
				stream->WriteLine("			JSONSetString(j3[\"" + m.name + "\"], c->" + m.name + ");");
			}
			else if (m.type.Left(11) == "shared_ptr<")
			{
				stream->WriteLine("			if (c->" + m.name + " != NULL && c->" + m.name + "->As<Entity>()) j3[\"" + m.name + "\"] = c->" + m.name + "->As<Entity>()->GetGUID();");
				stream->WriteLine("			if (c->" + m.name + " == NULL) j3[\"" + m.name + "\"] = nullptr;");
			}
		}

		stream->WriteLine("		}");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return true;");
	stream->WriteLine("}\n");

	stream->WriteLine("bool _LoadComponentState(shared_ptr<Component> component, nlohmann::json& j3)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		if (c.members.empty()) continue;

		stream->WriteLine("	{");
		stream->WriteLine("		auto c = component->As<::" + c.name + ">();");
		stream->WriteLine("		if (c) {");

		for (auto m : c.members)
		{
			if (m.type == "float" or m.type == "double" or m.type == "dFloat" or m.type == "int")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_number()) c->" + m.name + " = " + "j3[\"" + m.name + "\"];");
			}
			else if (m.type == "bool")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_boolean()) c->" + m.name + " = " + "j3[\"" + m.name + "\"];");
			}
			else if (m.type == "string" or m.type == "std::string" or m.type == "String")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_string()) c->" + m.name + " = " + "j3[\"" + m.name + "\"];");
			}
			else if (m.type == "Vec2" or m.type == "dVec2" or m.type == "iVec2")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_array() and j3[\"" + m.name + "\"].size()==2) c->" + m.name + " = " + m.type + "( j3[\"" + m.name + "\"][0], j3[\"" + m.name + "\"][1]);");
			}
			else if (m.type == "Vec3" or m.type == "dVec3" or m.type == "iVec3")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_array() and j3[\"" + m.name + "\"].size()==3) c->" + m.name + " = " + m.type + "( j3[\"" + m.name + "\"][0], j3[\"" + m.name + "\"][1], j3[\"" + m.name + "\"][2]);");
			}
			else if (m.type == "Vec4" or m.type == "dVec4" or m.type == "iVec4" or m.type == "Plane" or m.type == "dPlane" or m.type == "Quat" or m.type == "dQuat")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_array() and j3[\"" + m.name + "\"].size()==3) c->" + m.name + " = " + m.type + "( j3[\"" + m.name + "\"][0], j3[\"" + m.name + "\"][1], j3[\"" + m.name + "\"][2], j3[\"" + m.name + "\"][3]);");
			}
			else if (m.type == "WString" or m.type == "String")
			{
				stream->WriteLine("			c->" + m.name + " = JSONGetString(j3[\"" + m.name + "\"]);");
			}
		}
		stream->WriteLine("		}");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return true;");
	stream->WriteLine("}");

	stream->WriteLine("\n shared_ptr<Component> _CopyComponent(shared_ptr<Component> component)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		stream->WriteLine("	{");
		stream->WriteLine("		auto c = component->As<::" + c.name + ">();");
		stream->WriteLine("		if (c != NULL) return std::make_shared<" + c.name + ">(*c);");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return NULL;");
	stream->WriteLine("}");

	/*stream->WriteLine("\nbool _CopyComponentState(shared_ptr<Component> c1, shared_ptr<Component> c2)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		if (c.members.empty()) continue;

		stream->WriteLine("	{");
		stream->WriteLine("		auto dc1 = c1->As<" + c.name + ">();");
		stream->WriteLine("		auto dc2 = c2->As<" + c.name + ">();");
		stream->WriteLine("		if (dc1 != NULL && dc2 != NULL) {");

		for (auto m : c.members)
		{
			stream->WriteLine("			dc2->" + m.name + " = dc1->" + m.name + ";");
		}

		stream->WriteLine("		}");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return true;");
	stream->WriteLine("}");*/

	//SetFileMode("Source/ComponentSystem.cpp", 33206);

	if (!stream->data->Save("Source/ComponentSystem.cpp"))
	{
		Print("Error: Failed to write file \"Source/ComponentSystem.cpp\"");
		return 1;
	}

	//SetFileMode("Source/ComponentSystem.cpp", 4);

	return 0;
}

int main(int argc, const char* argv[])
{
	Print("Running pre-processor...");
	auto tm = Millisecs();
	//UltraCore::GameEngine::Get();
	if (FileType("Source/ComponentSystem.h") == 0 or FileType("Source/ComponentSystem.cpp") == 0) rebuild = true;
	headertime = FileTime("Source/ComponentSystem.h");
	headertime = min(headertime, FileTime("Source/ComponentSystem.h"));
	ProcessDir("");
	int result = WriteHeaders();
	Print("Time Elapsed: " + String(Millisecs() - tm) + " milliseconds");
	return result;
}