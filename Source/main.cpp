#include "UltraEngine.h"
using namespace UltraEngine;

// 230102 - reep: Comment me out if you're compiling with the full engine.
#if !defined (Eof)
#define Eof EOF
#endif

struct Member
{
	String name;
	String type;
};

struct Argument
{
	String name;
	String type;
	String defaultvalue;
};

class Method
{
public:
	String name;
	std::vector<Argument> arguments;
	String returntype;
};

bool operator<(const Method& m1, const Method& m2)
{
	if (m1.name < m2.name) return true;
	if (m1.name > m2.name) return false;
	if (m1.arguments.size() < m2.arguments.size()) return true;
	if (m1.arguments.size() > m2.arguments.size()) return false;
	for (int n = 0; n < m1.arguments.size(); ++n)
	{
		if (m1.arguments[n].type < m2.arguments[n].type) return true;
		if (m1.arguments[n].type > m2.arguments[n].type) return false;
	}
	return false;
}

struct Class
{
	String dir;
	String name;
	std::vector<Member> members;
};

struct ComponentInfo
{
	String name;
	String path;
};

static std::map<Method, std::set<String> > methodclasses;
static std::vector<String> components;
static std::vector<ComponentInfo> componentinfos;
static bool rebuild = false;
static uint64_t headertime = 0;
static String pchfile = "UltraEngine.h";

void ProcessDir(const WString& path, const WString& componentpath = "Source/Components/")
{
	//Path to game's component headers
	WString path_to_components = componentpath;

	//Check to see if there's a trailing backslash. If there isn't one, add one!
	if (path_to_components.Right(1) != "/") path_to_components = path_to_components + "/";

	//Index the directory of the components.

	//Create the directory if it doesn't exist.
	if (FileType(path_to_components) != 2)
	{
		if (!CreateDir(path_to_components))
		{
			Print("Error: Failed to create directory \"" + path_to_components + "\"!");
		}
	}

	auto dir = LoadDir(path_to_components + path);
	for (WString file : dir)
	{
		auto fullpath = file;
		if (path != "") fullpath = path + "/" + file;
		auto ext = ExtractExt(file).Lower();
		if (FileType(path_to_components + fullpath) == 1)
		{
			if (ext == "h" or ext == "hpp")
			{
				if (rebuild == false and FileTime(path_to_components + fullpath) > headertime)
				{
					Print("Forcing a rebuild as \"" + path_to_components + fullpath + "\" has been updated since the creation of the component system header file.");
					rebuild = true;
				}

				ComponentInfo info;
				info.name = file.ToString();
				info.path = path.ToString();
				componentinfos.push_back(info);
				components.push_back(info.name);
			}
		}
		else if (FileType(path_to_components + fullpath) == 2)
		{
			ProcessDir(fullpath, componentpath);
		}
	}
}

// Return the generation time.
static String generation_time = "";
const String GenerationTimestamp()
{
	auto now = std::chrono::system_clock::now();
	std::time_t end_time = std::chrono::system_clock::to_time_t(now);
	return String(std::ctime(&end_time));
}

//This has to be a separate functon or the stack gets too big when sol is initialized
int WriteHeaders(const WString& srcdir = "Source/", const WString& filename = "ComponentSystem")
{
	if (!rebuild)
	{
		Print("All files are up-to-date.");
		return 0;
	}

	//Path to game's source directory
	WString path_to_src = srcdir;

	//Check to see if there's a trailing backslash. If there isn't one, add one!
	if (path_to_src.Right(1) != "/") path_to_src = path_to_src + "/";

	//ComponentSystem.cpp/ComponentSystem.h
	const WString componentsystemcpp = filename + ".cpp";
	const WString componentsystemheader = filename + ".h";

	//Path to game's component headers
	const String component_dir = "Components/"; // Subfolder
	const WString path_to_components = srcdir + component_dir; //Fullpath (Source/Components/)

	//auto stream = WriteFile("Source/Component System.h");
	auto stream = CreateBufferStream();
	if (stream == NULL)
	{
		Print("Error: Failed to write file \"" + path_to_src + componentsystemheader + "\"");
		return 1;
	}

	stream->WriteLine("// This file is generated by the pre-processor on " + generation_time + "// Please do not do not modify this file!");
	//stream->WriteLine("//-----------------------------------------------------------------------");
	//stream->WriteLine("//");
	//stream->WriteLine("// This file is generated by the pre-processor. Do not modify it.");
	//stream->WriteLine("// Generated on: " + generation_time + "//");
	//stream->WriteLine("//-----------------------------------------------------------------------");
	//stream->WriteLine("");

	stream->WriteLine("#pragma once");
	stream->WriteLine("#include \"" + pchfile + "\"");
	stream->WriteLine("");
	stream->WriteLine("using namespace UltraEngine;");
	stream->WriteLine("using namespace std;\n");

	stream->WriteLine("class Component;");
	stream->WriteLine("class Actor;");
	stream->WriteLine("extern bool _LoadComponentState(shared_ptr<Component> component, nlohmann::json & j3);");
	stream->WriteLine("extern bool _SaveComponentState(shared_ptr<Component> component, nlohmann::json & j3);");
	stream->WriteLine("extern shared_ptr<Component> _CopyComponent(shared_ptr<Component> component);");
	stream->WriteLine("extern std::shared_ptr<Actor> GetEntityActor(std::shared_ptr<Entity> entity);");
	//stream->WriteLine("extern bool _CopyComponentState(shared_ptr<Component> c1, shared_ptr<Component> c2);");
	//stream->WriteLine("extern void InitComponentSystem();");
	//stream->WriteLine("extern shared_ptr<Actor> GetEntityActor(shared_ptr<Entity> entity);");
	stream->WriteLine("");

	std::set<String> classeswithupdatemethod;
	std::set<String> classeswithstartmethod;

	std::vector<Class> classes;
	std::set<Method> methods;

	for (auto c : componentinfos)
	{
		bool ispublic = false;
		bool methodsstarted = false;
		//Print("");
		//Print(c);

		Class cclass;
		cclass.name = StripExt(c.name);
		cclass.name = cclass.name.Replace("-", "");
		cclass.name = cclass.name.Replace(" ", "");

		auto fullname = c.name;
		if (c.path != "") fullname = c.path + "/" + c.name;
		auto hs = ReadFile(path_to_components + fullname);

		if (hs == NULL) continue;

		while (!hs->Eof())
		{
			auto s = hs->ReadLine().Trim();
			int i = s.Find("//");

			if (i != -1) s = s.Left(i);

			if (s == "public:") ispublic = true;
			if (s == "private:") ispublic = false;
			if (s == "protected:") ispublic = false;

			if (s.Find("(") != -1) methodsstarted = true;

			if (ispublic)
			{
				if (s.Left(7) == "virtual")
				{
					s = s.Right((int)s.size() - 7).Trim();
					if (s.Left(1) == "~") continue;

					i = s.Find("(");
					auto left = s.Left(i).Trim();
					auto sarr = left.Split("");
					auto right = s.Right((int)s.size() - i - 1);
					i = right.Find(")");
					right = right.Left(i);

					auto funcname = sarr[sarr.size() - 1].Trim();

					//if (funcname == "Start") continue;					
					if (funcname == "ProcessEvent") continue;
					if (funcname == "Load") continue;
					if (funcname == "Save") continue;
					//if (funcname == "CopyState") continue;
					if (funcname == "Remove") continue;

					Method m;
					m.name = funcname;

					std::string rt;
					for (int n = 0; n < sarr.size() - 1; ++n)
					{
						rt += sarr[n];
					}
					m.returntype = rt;

					sarr = right.Split(",");

					for (int n = 0; n < sarr.size(); ++n)
					{
						Argument a;

						auto arg = sarr[n].Trim();
						auto sarr3 = arg.Split("=");

						if (sarr3.size() > 1)
						{
							a.defaultvalue = sarr3[sarr3.size() - 1].Trim();
						}

						auto sarr2 = sarr3[0].Split("");

						a.name = sarr2[sarr2.size() - 1];
						for (int k = 0; k < sarr2.size() - 1; ++k)
						{
							if (!a.type.empty()) a.type += " ";
							a.type += sarr2[k];
						}
						m.arguments.push_back(a);
					}

					if (funcname == "Start")
					{
						if (m.arguments.empty()) classeswithstartmethod.insert(cclass.name);
						continue;
					}

					if (funcname == "Update")
					{
						if (m.arguments.empty()) classeswithupdatemethod.insert(cclass.name);
						continue;
					}

					methods.insert(m);
					methodclasses[m].insert(cclass.name);
				}
				else
				{
					if (!ispublic) continue;
					if (methodsstarted) continue;
					if (s.Find(";") == -1) continue;
					s = s.Replace(";", "");

					//This handles default definition in member declaration:
					//int m = 3;
					{
						auto sarr = s.Split("=");
						if (sarr.size() > 1)
						{
							s = sarr[0].Trim();
						}
					}

					Member m;
					vector<String> types = { "WString", "String", "float", "dFloat", "int", "double", "bool", "Vec2", "Vec3", "Vec4", "Mat3", "Mat4", "Plane", "Quat", "dVec2", "dVec3", "dVec4", "dMat3", "dMat4", "dPlane", "dQuat", "iVec2", "iVec3", "iVec4" };

					bool found = false;
					for (auto type : types)
					{
						if (s.Left((int)type.size()) == type)
						{
							m.type = type;
							s = s.Right(int(s.size() - type.size() - 1));
							found = true;
							break;
						}
					}

					if (!found)
					{
						int i = s.Find(">");
						if (i > -1)
						{
							m.type = s.Left(i);
							s = s.Right(int(s.size() - m.type.size() - 1));
							m.type = m.type.Replace(" ", "");
						}
						else
						{
							i = s.Find(" ");
							if (i > -1)
							{
								m.type = s.Left(i);
								s = s.Right(int(s.size() - m.type.size() - 1));
							}
						}
					}

					if (m.type.Left(5) == "std::") m.type = m.type.Right((int)m.type.size() - 5);

					auto sarr = s.Split(",");
					for (int n = 0; n < sarr.size(); ++n)
					{
						m.name = sarr[n].Trim();
						cclass.members.push_back(m);
					}

				}
			}
		}
		classes.push_back(cclass);
		hs->Close();
	}

	/*stream->WriteLine("enum SignalID");
	stream->WriteLine("{");
	std::set<String> signals = { "	SIGNALID_COLLISION" };
	for (auto m : methods)
	{
		signals.insert("	SIGNALID_" + m.name.Upper());
	}
	String ss;
	bool started = false;
	for (auto s : signals)// int n = 0; n < signals.size(); ++n)
	{
		if (ss != "") ss += ",\n";
		ss += s;
		if (!started) ss += " = 10001";
		started = true;
		//if (n < signals.size() - 1) signals[n] += ",";
	}
	stream->WriteLine(ss);
	stream->WriteLine("};\n");*/

	std::set<Method> uniquemethods;
	for (auto m : methods)
	{
		m.name = "";
		uniquemethods.insert(m);
	}

	for (auto c : classes)
	{
		stream->WriteLine("class " + c.name + ";");
	}

	stream->WriteLine("\nclass Actor : public ActorBase");
	stream->WriteLine("{");
	//stream->WriteLine("	std::shared_ptr<Entity> m_entity;");

	for (auto c : classes)
	{
		stream->WriteLine("	std::shared_ptr<" + c.name + "> m_" + c.name.Lower() + ";");
	}

	int countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		stream->WriteLine("\n	struct ActorMethod" + String(countuniquemethods) + "Arguments");
		stream->WriteLine("	{");
		int a = 0;
		for (auto arg : m.arguments)
		{
			stream->WriteLine("		" + arg.type.Replace("const", "").Replace("&", "").Trim() + " arg" + String(a) + ";");
			a++;
		}
		stream->WriteLine("	};");
		countuniquemethods++;
	}

	stream->WriteLine("\n	struct ActorMethod");
	stream->WriteLine("	{");
	countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		String args;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ", ";
			args += arg.type;
		}
		stream->WriteLine("		" + m.returntype + " (Actor::* method" + String(countuniquemethods) + ")(" + args + ");");
		countuniquemethods++;
	}
	countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		stream->WriteLine("		ActorMethod" + String(countuniquemethods) + "Arguments args" + String(countuniquemethods) + ";");
		countuniquemethods++;
	}
	countuniquemethods = 0;
	String nullmethods;
	{
		String s = "\n		ActorMethod()";
		if (!uniquemethods.empty()) s += " :";
		for (auto m : uniquemethods)
		{
			if (countuniquemethods != 0) nullmethods += ",";
			nullmethods += " method" + String(countuniquemethods) + "(NULL)";
			countuniquemethods++;
		}
		stream->WriteLine(s + nullmethods);
	}
	stream->WriteLine("		{}");
	countuniquemethods = 0;
	{
		String s = "\n		void* GetPtr() {";
		for (auto m : uniquemethods)
		{
			s += "\n			if (method" + String(countuniquemethods) + ") return reinterpret_cast<void*&>(method" + String(countuniquemethods) + ");";
			countuniquemethods++;
		}
		s += "\n			return NULL;\n		};";
		stream->WriteLine(s);
	}
	countuniquemethods = 0;
	for (auto m : uniquemethods)
	{
		String args;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ", ";
			args += arg.type;
		}
		stream->WriteLine("\n		ActorMethod(" + m.returntype + " (Actor::* m)(" + args + ") ) : " + nullmethods + " {");
		stream->WriteLine("			method" + String(countuniquemethods) + " = m;");
		stream->WriteLine("		}");
		countuniquemethods++;
	}
	stream->WriteLine("	};\n");

	stream->WriteLine("\n	struct Connection\n\
	{\n\
		ActorMethod m;\n\
		std::function<void()> func;\n\
		std::shared_ptr<Actor> target;\n\
	};");

	//stream->WriteLine("	std::map<SignalID, std::list<::Connection > > connections;");
	stream->WriteLine("	std::map<void*, std::list<Connection > > connections;");

	stream->WriteLine("\nprivate:");
	stream->WriteLine("	virtual void AddComponent(std::shared_ptr<Component> component);");
	stream->WriteLine("\npublic:");
	stream->WriteLine("	virtual bool Update();");

	/*stream->WriteLine("	virtual void Connect(void* ptr, std::function<void()> func)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c;");
	stream->WriteLine("		c.func = func; ");
	//stream->WriteLine("		c.repeat = repeat;");
	stream->WriteLine("		c.method = NULL; ");
	stream->WriteLine("		connections[ptr].push_back(c);");
	stream->WriteLine("	}");
	stream->WriteLine("");

	stream->WriteLine("	virtual void Connect(void* ptr, void (Actor::* outmethod)(), std::shared_ptr<Actor> target)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c;");
	stream->WriteLine("		c.func = NULL; ");
	stream->WriteLine("		c.target = target;");
	stream->WriteLine("		if (c.target == Self()) c.target = NULL;");
	//stream->WriteLine("		c.repeat = repeat;");
	stream->WriteLine("		c.method = outmethod; ");
	stream->WriteLine("		connections[ptr].push_back(c);");
	stream->WriteLine("	}");
	stream->WriteLine("");*/

	stream->WriteLine("	void FireSignal(void* ptr)");
	stream->WriteLine("	{");
	stream->WriteLine("		auto& f = connections[ptr];");
	stream->WriteLine("		auto it = f.begin(); ");
	stream->WriteLine("		while (it != f.end())");
	stream->WriteLine("		{");
	stream->WriteLine("			if ((*it).func != NULL)");
	stream->WriteLine("			{");
	stream->WriteLine("				(*it).func();");
	stream->WriteLine("			}");
	stream->WriteLine("			else");
	stream->WriteLine("			{");
	stream->WriteLine("				auto t = (*it).target;");
	stream->WriteLine("				if (t == NULL) t = As<Actor>();");
	int ii = 0;
	for (auto m : uniquemethods)
	{
		String args;
		int iii = 0;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ", ";
			args += "(*it).m.args" + String(ii) + ".arg" + String(iii);
			iii++;
		}
		if (ii == 0)
		{
			stream->WriteLine("				if ((*it).m.method" + String(ii) + " != NULL)");
		}
		else
		{
			stream->WriteLine("				else if ((*it).m.method" + String(ii) + " != NULL)");
		}
		stream->WriteLine("				{");
		stream->WriteLine("					(t.get()->*((*it).m.method" + String(ii) + "))(" + args + ");");
		stream->WriteLine("				}");
		ii++;
	}
	//stream->WriteLine("				(t.get()->*((*it).method))();");
	stream->WriteLine("			}");
	//stream->WriteLine("			if (!(*it).repeat)");
	//stream->WriteLine("			{");
	//stream->WriteLine("				it = f.erase(it);");
	//stream->WriteLine("				continue; ");
	//stream->WriteLine("			}");
	stream->WriteLine("			++it; ");
	stream->WriteLine("		}");
	stream->WriteLine("	}");

	stream->WriteLine("\npublic:\n");

	stream->WriteLine("	virtual void Connect(ActorMethod inmethod, std::function<void()> func)");
	stream->WriteLine("	{\n\
		Connection c;\n\
		c.func = func;\n\
		connections[inmethod.GetPtr()].push_back(c);\n\
	}\n");
	//stream->WriteLine("	virtual void Connect(ActorMethod inmethod, void (Actor::* outmethod)(), std::shared_ptr<Actor> target = NULL)");
	//stream->WriteLine("	{");
	//stream->WriteLine("		Connect(inmethod.GetPtr(), outmethod, target);");
	//stream->WriteLine("	}");

	ii = 0;
	for (auto m : uniquemethods)
	{
		String args;
		for (auto arg : m.arguments)
		{
			if (args != "") args += ",";
			args += arg.type + " " + arg.name;
		}
		auto args2 = args;
		if (args2 != "") args2 = ", " + args2;
		stream->WriteLine("	virtual void Connect(ActorMethod inmethod, std::shared_ptr<Actor> target, " + m.returntype + "(Actor::* outmethod)(" + args + ")" + args2 + ")");
		stream->WriteLine("	{");
		stream->WriteLine("		Connection c;");
		stream->WriteLine("		c.m = outmethod;");
		stream->WriteLine("		c.target = target;");
		int iii = 0;
		for (auto arg : m.arguments)
		{
			stream->WriteLine("		c.m.args" + String(ii) + ".arg" + String(iii) + " = " + arg.name + ";");
			iii++;
		}
		stream->WriteLine("		connections[inmethod.GetPtr()].push_back(c);");
		stream->WriteLine("	}");
		stream->WriteLine("");
		ii++;
	}

	/*stream->WriteLine("	virtual void Connect(SignalID signalID, std::function<void()> func, const bool repeat = true)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c;");
	stream->WriteLine("		c.func = func; ");
	stream->WriteLine("		c.repeat = repeat;");
	stream->WriteLine("		c.method = NULL; ");
	stream->WriteLine("		connections[signalID].push_back(c);");
	stream->WriteLine("	}");
	stream->WriteLine("");
	stream->WriteLine("	virtual void Connect(SignalID signalID, void (Actor:: * method)(), const bool repeat = true)");
	stream->WriteLine("	{");
	stream->WriteLine("		Connection c; ");
	stream->WriteLine("		c.func = NULL;");
	stream->WriteLine("		c.repeat = repeat; ");
	stream->WriteLine("		c.method = method;");
	stream->WriteLine("		connections[signalID].push_back(c); ");
	stream->WriteLine("	}");
	stream->WriteLine("");
	stream->WriteLine("	virtual void FireSignal(SignalID signalID)");
	stream->WriteLine("	{");
	stream->WriteLine("		auto& f = connections[signalID];");
	stream->WriteLine("		auto it = f.begin(); ");
	stream->WriteLine("		while (it != f.end())");
	stream->WriteLine("		{");
	stream->WriteLine("			if ((*it).func != NULL)");
	stream->WriteLine("			{");
	stream->WriteLine("				(*it).func();");
	stream->WriteLine("			}");
	stream->WriteLine("			else");
	stream->WriteLine("			{");
	stream->WriteLine("				(this->*((*it).method))();");
	stream->WriteLine("			}");
	stream->WriteLine("			if (!(*it).repeat)");
	stream->WriteLine("			{");
	stream->WriteLine("				it = f.erase(it);");
	stream->WriteLine("				continue; ");
	stream->WriteLine("			}");
	stream->WriteLine("			++it; ");
	stream->WriteLine("		}");
	stream->WriteLine("	}");
	stream->WriteLine("");*/

	//stream->WriteLine("	const std::shared_ptr<Entity>& entity;");
	/*for (auto c : classes)
	{
		stream->WriteLine("	const std::shared_ptr<::" + c.name + ">& " + c.name.Lower() + ";");
	}*/

	stream->WriteLine("");

	//for (auto c : classes)
	//{
	//	stream->WriteLine("	std::shared_ptr<::" + c.name + "> " + c.name + "();");
	//}

	stream->WriteLine("	\n	Actor();");
	stream->WriteLine("	\n	virtual ~Actor();");
	//stream->WriteLine("	Actor(std::shared_ptr<Entity> entity);");

	stream->WriteLine("\n	template <class T>");
	stream->WriteLine("	shared_ptr<T> AddComponent()");
	stream->WriteLine("	{");
	stream->WriteLine("		auto c = std::make_shared<T>();");
	stream->WriteLine("		if (c->As<Component>() == NULL) RuntimeError(\"Class must be derived from Component.\");");
	stream->WriteLine("		AddComponent(c);");
	stream->WriteLine("		return c;");
	stream->WriteLine("	}");

	stream->WriteLine("\n	template <class T>");
	stream->WriteLine("	std::shared_ptr<T> GetComponent()");
	stream->WriteLine("	{");
	stream->WriteLine("		for (auto c : components)\n		{\n			auto o = std::dynamic_pointer_cast<T>(c);\n			if (o) return o;\n		}\n        return NULL;"); // 220102 - reep: This wasn't returning anything if null..
	stream->WriteLine("	}");

	stream->WriteLine("\n	virtual shared_ptr<Actor> Copy();");
	//stream->WriteLine("	virtual void Start();");

	stream->WriteLine("\nprotected:");
	stream->WriteLine("	virtual bool Load(nlohmann::json& j3);");
	stream->WriteLine("	virtual bool Save(nlohmann::json& j3);");
	stream->WriteLine("	virtual void Free();");

	stream->WriteLine("#ifdef DOUBLE_FLOAT");
	stream->WriteLine("	virtual void Collision(std::shared_ptr<Entity> collidedentity, const dVec3& position, const dVec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial);");
	stream->WriteLine("#else");
	stream->WriteLine("	virtual void Collision(std::shared_ptr<Entity> collidedentity, const Vec3& position, const Vec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial);");
	stream->WriteLine("#endif");

	for (auto c : methods)
	{
		String def;
		if (c.returntype == "bool") def = " = false";
		else if (c.returntype == "int") def = " = 0";
		else if (c.returntype == "float") def = " = 0.0f";
		else if (c.returntype == "double") def = " = 0.0";
		else if (c.returntype.Left(11) == "shared_ptr<") def = " = NULL";

		String args;
		String s = "	virtual " + c.returntype + " " + c.name + "(";
		for (auto arg : c.arguments)
		{
			if (!args.empty()) args = args + ", ";
			args += arg.type + " " + arg.name;
			if (arg.defaultvalue != "") args = args + " = " + arg.defaultvalue;
		}
		s += args + ");";

		stream->WriteLine(s);
	}

	stream->WriteLine("	friend std::shared_ptr<Actor> CreateActor(std::shared_ptr<Entity>);");
	stream->WriteLine("};");
	stream->WriteLine("");

	stream->WriteLine("class FinalActorFactory : public UltraEngine::Core::ActorFactory {");
	stream->WriteLine("	public:");
	stream->WriteLine("	shared_ptr<ActorBase> CreateActor()");
	stream->WriteLine("	{");
	stream->WriteLine("		return make_shared<Actor>();");
	stream->WriteLine("	}");
	stream->WriteLine("};\n");

	stream->WriteLine("inline int InitializeComponentSystem() {");
	stream->WriteLine("	UltraEngine::Core::systemactorfactory = new FinalActorFactory;");
	stream->WriteLine("	return 0;");
	stream->WriteLine("}\n");
	stream->WriteLine("inline int _init = InitializeComponentSystem();\n");

	//auto stream2 = WriteFile("Source/Component System.cpp");
	auto stream2 = CreateBufferStream();
	//if (stream2 == NULL)
	//{
	//	Print("Error: Failed to write file \"Source/Component System.cpp\".");
	//	return 1;
	//}

	stream2->WriteLine("// This file is generated by the pre-processor on " + generation_time + "// Please do not do not modify this file!");
	//stream2->WriteLine("//-----------------------------------------------------------------------");
	//stream2->WriteLine("//");
	//stream2->WriteLine("// This file is generated by the pre-processor. Do not modify it.");
	//stream2->WriteLine("// Generated on: " + generation_time + "//");
	//stream2->WriteLine("//-----------------------------------------------------------------------");
	//stream2->WriteLine("");

	stream2->WriteLine("#include \"" + pchfile + "\"");
	stream2->WriteLine("#include \"" + componentsystemheader.ToString() + "\"");
	stream2->WriteLine("");
	stream2->WriteLine("using namespace UltraEngine;");
	stream2->WriteLine("using namespace std;");
	stream2->WriteLine("");
	//stream2->WriteLine("shared_ptr<Actor> GetEntityActor(shared_ptr<Entity> entity) { return entity->actor->As<Actor>();}");

	stream2->WriteLine("std::shared_ptr<Actor> GetEntityActor(std::shared_ptr<Entity> entity)");
	stream2->WriteLine("{");
	stream2->WriteLine("	if (entity == NULL) RuntimeError(\"Entity must not be NULL\");");
	stream2->WriteLine("	return std::dynamic_pointer_cast<Actor>(entity->actor.lock());");
	stream2->WriteLine("}");
	stream2->WriteLine("");

	stream2->WriteLine("Component::Component()");
	//stream2->WriteLine("Component::Component() : entity(m_entity)");
	stream2->WriteLine("{}");

	//stream2->WriteLine("\nvoid Component::Start()");
	//stream2->WriteLine("{}");

	stream2->WriteLine("\nvoid Component::Update()");
	stream2->WriteLine("{}");

	String defaults;// = " : entity(m_entity)";
	/*for (auto c : classes)
	{
		if (defaults == "") defaults += " :\n"; else defaults += ",\n";
		defaults += c.name.Lower() + "(m_" + c.name.Lower() + ")";
	}*/

	stream2->WriteLine("\nActor::Actor()" + defaults);
	stream2->WriteLine("{}");

	stream2->WriteLine("\nActor::~Actor()" + defaults);
	stream2->WriteLine("{");
	for (auto c : classes)
	{
		stream2->WriteLine("	if (m_" + c.name.Lower() + ") m_" + c.name.Lower() + "->actor = NULL;");
	}
	stream2->WriteLine("}");

	// Actor::Load implementation
	stream2->WriteLine("\nbool Actor::Load(nlohmann::json & j3) \n\
{\n\
	if (j3[\"components\"].is_array())\n\
	{\n\
		for (auto& info : j3[\"components\"])\n\
		{\n\
			shared_ptr<Component> c;\n\
			if (!info[\"class\"].is_string()) continue;");
	for (auto c : classes)
	{
		stream2->WriteLine("			if (info[\"class\"] == \"" + c.name + "\") c = std::make_shared<::" + c.name + ">();");
	}
	stream2->WriteLine("			if (c == NULL) continue;");
	stream2->WriteLine("			if (!_LoadComponentState(c, info)) return false;");
	stream2->WriteLine("			AddComponent(c);");
	stream2->WriteLine("		}\n\
	}\n\
	return true;\n\
}");

	stream2->WriteLine("\nbool Actor::Save(nlohmann::json& j3)");
	stream2->WriteLine("{");
	stream2->WriteLine("	j3[\"components\"] = nlohmann::json::array();");
	for (auto c : classes)
	{
		stream2->WriteLine("	if (m_" + c.name.Lower() + ")");
		stream2->WriteLine("	{");
		stream2->WriteLine("		nlohmann::json info = nlohmann::json::object();");
		stream2->WriteLine("		if (!m_" + c.name.Lower() + "->Save(info)) return false;");
		stream2->WriteLine("		info[\"class\"] = \"" + c.name + "\";");
		stream2->WriteLine("		j3[\"components\"].push_back(info);");
		stream2->WriteLine("	}");
	}
	stream2->WriteLine("	return true;");
	stream2->WriteLine("}");

	stream2->WriteLine("\n#ifdef DOUBLE_FLOAT");
	stream2->WriteLine("void Actor::Collision(std::shared_ptr<Entity> collidedentity, const dVec3& position, const dVec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial)");
	stream2->WriteLine("#else");
	stream2->WriteLine("void Actor::Collision(std::shared_ptr<Entity> collidedentity, const Vec3& position, const Vec3& normal, const dFloat speed, std::shared_ptr<Material> collidedmaterial)");
	stream2->WriteLine("#endif");
	stream2->WriteLine("{");
	stream2->WriteLine("	ActorBase::Start();");
	stream2->WriteLine("	auto actorbase = collidedentity->actor.lock();");
	stream2->WriteLine("	std::shared_ptr<Actor> actor;");
	stream2->WriteLine("	if (actorbase) actor = actorbase->As<Actor>();");
	stream2->WriteLine("	if (actor == NULL) actor = CreateActor(collidedentity);");
	for (auto c : classes)
	{
		stream2->WriteLine("	if (this->m_" + c.name.Lower() + ") this->m_" + c.name.Lower() + "->Collide(actor,position,normal,speed);");
	}
	/*
	stream2->WriteLine("#ifdef DOUBLE_FLOAT");
	stream2->WriteLine("void(Actor::* methodptr)(shared_ptr<Actor>, const dVec3&, const dVec3&, const dFloat, shared_ptr<Material>) = &Actor::Collision;");
	stream2->WriteLine("#else");
	stream2->WriteLine("void(Actor::* methodptr)(shared_ptr<Actor>, const Vec3&, const Vec3&, const dFloat, shared_ptr<Material>) = &Actor::Collision;");
	stream2->WriteLine("#endif");
	stream2->WriteLine("FireSignal(reinterpret_cast<void*&>(methodptr));");
	//stream2->WriteLine("	FireSignal(SIGNALID_COLLISION);");
	stream2->WriteLine("}");*/

	/*stream2->WriteLine("\nvoid Actor::Start()");
	stream2->WriteLine("{");
	for (auto c : classeswithstartmethod)
	{
		stream2->WriteLine("	if (this->" + c.Lower() + ") this->" + c.Lower() + "->Start();");
	}*/
	stream2->WriteLine("}");

	stream2->WriteLine("\nvoid Actor::Free()");
	stream2->WriteLine("{");
	stream2->WriteLine("	connections.clear();");
	stream2->WriteLine("	m_entity = NULL;");
	stream2->WriteLine("}");

	stream2->WriteLine("\nbool Actor::Update()");
	stream2->WriteLine("{");
	stream2->WriteLine("	ActorBase::Start();");
	stream2->WriteLine("	bool succ = false;");
	for (auto c : classeswithupdatemethod)
	{
		stream2->WriteLine("	if (this->m_" + c.Lower() + ")");
		stream2->WriteLine("	{");
		stream2->WriteLine("		this->m_" + c.Lower() + "->Update(); ");
		stream2->WriteLine("		succ = true;");
		stream2->WriteLine("	}");
	}
	stream2->WriteLine("	return succ;");
	stream2->WriteLine("}");

	stream2->WriteLine("\nshared_ptr<Actor> Actor::Copy()");
	stream2->WriteLine("{");
	stream2->WriteLine("	shared_ptr<Entity> e;");
	stream2->WriteLine("	if (this->entity) e = this->entity->Instantiate();");
	stream2->WriteLine("	if (e) e->ResetUpdateHook();");
	stream2->WriteLine("	shared_ptr<Actor> copy = CreateActor(e);");
	stream2->WriteLine("	if (e) e->actor = copy;");
	for (auto c : classes)
	{
		//stream2->WriteLine("	{");
		stream2->WriteLine("		if (this->m_" + c.name.Lower() + ")");
		stream2->WriteLine("		{");
		stream2->WriteLine("			auto o = this->m_" + c.name.Lower() + "->Copy();");
		stream2->WriteLine("			auto oo = o->As<::" + c.name + ">();");
		stream2->WriteLine("			copy->AddComponent(oo);");
		//stream2->WriteLine("			oo->m_entity = e;");
		//stream2->WriteLine("			oo->actor = copy;");
		//stream2->WriteLine("			copy->m_" + c.name.Lower() + " = oo;");
		stream2->WriteLine("		}");
		//stream2->WriteLine("	}");
	}
	//stream2->WriteLine("// NO BAD!!!	copy->connections = this->connections;");
	//stream2->WriteLine("	if (callstart) copy->Start();");
	stream2->WriteLine("	return copy;");
	stream2->WriteLine("}\n");

	stream2->WriteLine("std::shared_ptr<Actor> CreateActor(std::shared_ptr<Entity> e)");
	stream2->WriteLine("{");
	stream2->WriteLine("	auto a = std::make_shared<Actor>();");
	stream2->WriteLine("	a->m_entity = e;");
	stream2->WriteLine("	if (e) e->actor = a;");
	stream2->WriteLine("	return a;");
	stream2->WriteLine("}\n");

	stream2->WriteLine("void Actor::AddComponent(std::shared_ptr<Component> c)");
	stream2->WriteLine("{");
	stream2->WriteLine("	if (c == NULL) RuntimeError(\"Component is NULL\");");
	stream2->WriteLine("	if (entity) entity->ResetUpdateHook();");
	//stream2->WriteLine("	c->m_entity = this->entity;");
	stream2->WriteLine("	c->entity = this->entity;");
	//	stream2->WriteLine("	c->actor = this->As<Actor>();");
	stream2->WriteLine("	c->actor = this;");

	for (auto c : classes)
	{
		stream2->WriteLine("	{");
		stream2->WriteLine("		auto o = c->As<::" + c.name + ">();");
		stream2->WriteLine("		if (o) this->m_" + c.name.Lower() + " = o;");
		stream2->WriteLine("	}");
	}
	stream2->WriteLine("	ActorBase::AddComponent(c);");
	//stream2->WriteLine("	if (callstart) c->Start();");
	stream2->WriteLine("}\n");

	/*for (auto c : classes)
	{
		stream2->WriteLine("std::shared_ptr<::" + c.name + "> Actor::" + c.name + "()");
		stream2->WriteLine("{");
		stream2->WriteLine("	if (m_" + c.name.Lower() + ") return m_" + c.name.Lower() + ";");
		stream2->WriteLine("	m_" + c.name.Lower() + " = make_shared<::" + c.name + ">();");
		//		stream2->WriteLine("	m_" + c.name.Lower() + "->Start();");
		stream2->WriteLine("	AddComponent(m_" + c.name.Lower() + ");");
		stream2->WriteLine("	return m_" + c.name.Lower() + ";");
		stream2->WriteLine("}\n");
	}*/

	for (auto c : methods)
	{
		String def;
		if (c.returntype == "bool") def = " = false";
		else if (c.returntype == "int") def = " = 0";
		else if (c.returntype == "float") def = " = 0.0f";
		else if (c.returntype == "double") def = " = 0.0";
		else if (c.returntype.Left(11) == "shared_ptr<") def = " = NULL";

		String args;
		String s = "" + c.returntype + " Actor::" + c.name + "(";
		for (auto arg : c.arguments)
		{
			if (!args.empty()) args = args + ", ";
			args += arg.type + " " + arg.name;
			if (arg.defaultvalue != "") args = args + " = " + arg.defaultvalue;
		}
		s += args + ")";

		stream2->WriteLine(s);

		stream2->WriteLine("{");
		if (c.returntype != "void") stream2->WriteLine("	" + c.returntype + " result" + def + ";");

		stream2->WriteLine("	ActorBase::Start();");

		for (auto cs : methodclasses[c])
		{
			//stream2->WriteLine("		auto c = component->As<" + cs + ">();");
			stream2->WriteLine("	if (this->m_" + cs.Lower() + " != NULL)");
			stream2->WriteLine("	{");
			args = "";
			for (auto arg : c.arguments)
			{
				if (!args.empty()) args = args + ", ";
				args += arg.name;
			}
			auto ss = "this->m_" + cs.Lower() + "->" + c.name + "(" + args + ");";
			if (c.returntype != "void") ss = "result = " + ss;
			stream2->WriteLine("		" + ss);
			if (c.returntype != "void") stream2->WriteLine("		return result;");
			stream2->WriteLine("	}");
		}

		/*
		String desc = c.returntype + "(Actor:: * methodptr)(";
		args = "";
		for (auto a : c.arguments)
		{
			if (args != "") args += ", ";
			args += a.type;
		}
		desc += args + ")";
		stream2->WriteLine("	" + desc + " = &Actor::" + c.name + ";");
		stream2->WriteLine("	FireSignal(reinterpret_cast<void*&>(methodptr));");
		//stream2->WriteLine("	FireSignal(SIGNALID_" + c.name.Upper() + ");");
		if (c.returntype != "void") stream2->WriteLine("	return result;");*/
		stream2->WriteLine("}");

		stream2->WriteLine("");
	}

	/*
	stream2->WriteLine("bool SceneLoader::LoadActor(shared_ptr<Entity> entity, nlohmann::json & j3)");
	stream2->WriteLine("{");
	stream2->WriteLine("	if (j3.is_object())");
	stream2->WriteLine("	{");
	stream2->WriteLine("		if (j3[\"components\"].is_array() && j3[\"components\"].empty() == false)");
	stream2->WriteLine("		{");
	stream2->WriteLine("			auto actor = CreateActor(entity);");
	stream2->WriteLine("			if (!actor->Load(j3)) return false;");
	stream2->WriteLine("			actors.push_back(actor);");
	stream2->WriteLine("		}");
	stream2->WriteLine("	}");
	stream2->WriteLine("	return Scene::LoadActor(entity, j3);");
	stream2->WriteLine("}");
	stream2->WriteLine("");
	stream2->WriteLine("shared_ptr<SceneLoader> LoadSceneEx(shared_ptr<World> world, const WString & path, const LoadFlags flags)");
	stream2->WriteLine("{");
	stream2->WriteLine("	auto stream = ReadFile(path);");
	stream2->WriteLine("	if (stream == NULL) return NULL;");
	stream2->WriteLine("	auto binstream = ReadFile(StripExt(path) + L\".bin\");");
	stream2->WriteLine("	auto scene = make_shared<SceneLoader>();");
	stream2->WriteLine("	auto j3 = LoadJSON(stream);");
	stream2->WriteLine("	if (!j3.is_object()) return NULL;");
	stream2->WriteLine("	if (!scene->Load(world, j3, binstream, flags)) return NULL;");
	stream2->WriteLine("	return scene;");
	stream2->WriteLine("}\n");

	stream->WriteLine("class SceneLoader : public Scene");
	stream->WriteLine("{");
	stream->WriteLine("	virtual bool LoadActor(shared_ptr<Entity> entity, nlohmann::json& j3);");
	stream->WriteLine("public:");
	stream->WriteLine("	std::vector<std::shared_ptr<Actor> > actors;");
	stream->WriteLine("};");
	stream->WriteLine("");
	stream->WriteLine("#define LoadScene LoadSceneEx");
	stream->WriteLine("");
	stream->WriteLine("extern shared_ptr<SceneLoader> LoadSceneEx(shared_ptr<World> world, const WString & path, const LoadFlags flags = LOAD_DEFAULT);");
	*/
	stream->WriteLine("extern std::shared_ptr<Actor> CreateActor(std::shared_ptr<Entity> entity = NULL);\n");

	stream->WriteLine("class Component : public ComponentBase");
	stream->WriteLine("{");
	//stream->WriteLine("	std::shared_ptr<Entity> m_entity;");
	stream->WriteLine("public:");
	stream->WriteLine("\n	std::shared_ptr<Entity> entity;");
	//stream->WriteLine("\n	std::weak_ptr<Actor> actor;");
	stream->WriteLine("\n	Actor* actor;");
	//stream->WriteLine("	const std::shared_ptr<Entity>& entity;\n");
	stream->WriteLine("	Component();\n");

	stream->WriteLine("protected:");
	stream->WriteLine("#ifdef DOUBLE_FLOAT");
	stream->WriteLine("	virtual void Collide(shared_ptr<Actor> collidedactor, const dVec3& position, const dVec3& normal, const dFloat speed) {}");
	stream->WriteLine("#else");
	stream->WriteLine("	virtual void Collide(shared_ptr<Actor> collidedactor, const Vec3& position, const Vec3& normal, const dFloat speed) {}");
	stream->WriteLine("#endif");

	//stream->WriteLine("	virtual void Start();");
	stream->WriteLine("	virtual void Update();");

	stream->WriteLine("	virtual bool Load(nlohmann::json& j3)");
	stream->WriteLine("	{");
	stream->WriteLine("		return _LoadComponentState(As<Component>(), j3);");
	stream->WriteLine("	}");

	stream->WriteLine("\n	virtual bool Save(nlohmann::json& j3)");
	stream->WriteLine("	{");
	stream->WriteLine("		return _SaveComponentState(As<Component>(), j3);");
	stream->WriteLine("	}");

	//stream->WriteLine("\n	virtual std::shared_ptr<Actor> GetActor()");
	//stream->WriteLine("	{");
	//stream->WriteLine("		return std::dynamic_pointer_cast<Actor>(this->actor.lock());");
	//stream->WriteLine("	}");

	stream->WriteLine("\n	virtual shared_ptr<Component> Copy()");
	stream->WriteLine("	{");
	stream->WriteLine("		auto c = _CopyComponent(As<Component>());");
	stream->WriteLine("		if (c == NULL) return NULL;");
	//stream->WriteLine("		if (!CopyState(c)) return NULL;");
	stream->WriteLine("		return c;");
	stream->WriteLine("	}");

	//stream->WriteLine("\n	virtual bool CopyState(shared_ptr<Component> c)");
	//stream->WriteLine("	{");
	//stream->WriteLine("		if (!_CopyComponentState(As<Component>(), c->As<Component>())) return false;");
	//stream->WriteLine("		return true;//Component::CopyState(c);");
	//stream->WriteLine("	}");
	stream->WriteLine("	\n	friend Actor;");
	stream->WriteLine("};\n");

	for (auto ci : componentinfos)
	{
		if (ci.path != "") ci.path += "/";
		stream->WriteLine("#include \"" + component_dir + ci.path + ci.name + "\"");
	}

	//bool succ = SetFileMode(path_to_src + componentsystemheader, 33206);

	if (!stream->data->Save(path_to_src + componentsystemheader))
	{
		Print("Error: Failed to write file \"" + path_to_src + componentsystemheader + "\"");
		return 1;
	}

	//SetFileMode(path_to_src + componentsystemheader, 4);

	stream = stream2;

	stream->WriteLine("bool _SaveComponentState(shared_ptr<Component> component, nlohmann::json& j3)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		if (c.members.empty()) continue;

		stream->WriteLine("	{");
		stream->WriteLine("		auto c = component->As<::" + c.name + ">();");
		stream->WriteLine("		if (c) {");

		for (auto m : c.members)
		{
			if (m.type == "Vec2" or m.type == "dVec2" or m.type == "iVec2")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { c->" + m.name + ".x, c->" + m.name + ".y };");
			}
			else if (m.type == "Vec3" or m.type == "dVec3" or m.type == "iVec3")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { c->" + m.name + ".x, c->" + m.name + ".y, c->" + m.name + ".z };");
			}
			else if (m.type == "Vec4" or m.type == "dVec4" or m.type == "iVec4")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { c->" + m.name + ".x, c->" + m.name + ".y, c->" + m.name + ".z, c->" + m.name + ".w };");
			}
			else if (m.type == "shared_ptr<Entity>")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = { this->m_" + m.name + "->GetUuid();");
			}
			else if (m.type == "bool" or m.type == "int" or m.type == "float" or m.type == "double" or m.type == "String" or m.type == "std::string" or m.type == "wstring" or m.type == "dFloat")
			{
				stream->WriteLine("			j3[\"" + m.name + "\"] = c->" + m.name + ";");
			}
			else if (m.type == "WString" or m.type == "String")
			{
				stream->WriteLine("			JSONSetString(j3[\"" + m.name + "\"], c->" + m.name + ");");
			}
			else if (m.type.Left(11) == "shared_ptr<")
			{
				stream->WriteLine("			if (c->" + m.name + " != NULL && c->" + m.name + "->As<Entity>()) j3[\"" + m.name + "\"] = c->" + m.name + "->As<Entity>()->GetUuid();");
				stream->WriteLine("			if (c->" + m.name + " == NULL) j3[\"" + m.name + "\"] = nullptr;");
			}
		}

		stream->WriteLine("		}");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return true;");
	stream->WriteLine("}\n");

	stream->WriteLine("bool _LoadComponentState(shared_ptr<Component> component, nlohmann::json& j3)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		if (c.members.empty()) continue;

		stream->WriteLine("	{");
		stream->WriteLine("		auto c = component->As<::" + c.name + ">();");
		stream->WriteLine("		if (c) {");

		for (auto m : c.members)
		{
			if (m.type == "float" or m.type == "double" or m.type == "dFloat" or m.type == "int")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_number()) c->" + m.name + " = " + "j3[\"" + m.name + "\"];");
			}
			else if (m.type == "bool")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_boolean()) c->" + m.name + " = " + "j3[\"" + m.name + "\"];");
			}
			else if (m.type == "string" or m.type == "std::string" or m.type == "String")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_string()) c->" + m.name + " = " + "j3[\"" + m.name + "\"];");
			}
			else if (m.type == "Vec2" or m.type == "dVec2" or m.type == "iVec2")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_array() and j3[\"" + m.name + "\"].size()==2) c->" + m.name + " = " + m.type + "( j3[\"" + m.name + "\"][0], j3[\"" + m.name + "\"][1]);");
			}
			else if (m.type == "Vec3" or m.type == "dVec3" or m.type == "iVec3")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_array() and j3[\"" + m.name + "\"].size()==3) c->" + m.name + " = " + m.type + "( j3[\"" + m.name + "\"][0], j3[\"" + m.name + "\"][1], j3[\"" + m.name + "\"][2]);");
			}
			else if (m.type == "Vec4" or m.type == "dVec4" or m.type == "iVec4" or m.type == "Plane" or m.type == "dPlane" or m.type == "Quat" or m.type == "dQuat")
			{
				stream->WriteLine("			if (j3[\"" + m.name + "\"].is_array() and j3[\"" + m.name + "\"].size()==3) c->" + m.name + " = " + m.type + "( j3[\"" + m.name + "\"][0], j3[\"" + m.name + "\"][1], j3[\"" + m.name + "\"][2], j3[\"" + m.name + "\"][3]);");
			}
			else if (m.type == "WString" or m.type == "String")
			{
				stream->WriteLine("			c->" + m.name + " = JSONGetString(j3[\"" + m.name + "\"]);");
			}
		}
		stream->WriteLine("		}");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return true;");
	stream->WriteLine("}");

	stream->WriteLine("\n shared_ptr<Component> _CopyComponent(shared_ptr<Component> component)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		stream->WriteLine("	{");
		stream->WriteLine("		auto c = component->As<::" + c.name + ">();");
		stream->WriteLine("		if (c != NULL) return std::make_shared<" + c.name + ">(*c);");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return NULL;");
	stream->WriteLine("}");

	/*stream->WriteLine("\nbool _CopyComponentState(shared_ptr<Component> c1, shared_ptr<Component> c2)");
	stream->WriteLine("{");
	for (auto c : classes)
	{
		if (c.members.empty()) continue;

		stream->WriteLine("	{");
		stream->WriteLine("		auto dc1 = c1->As<" + c.name + ">();");
		stream->WriteLine("		auto dc2 = c2->As<" + c.name + ">();");
		stream->WriteLine("		if (dc1 != NULL && dc2 != NULL) {");

		for (auto m : c.members)
		{
			stream->WriteLine("			dc2->" + m.name + " = dc1->" + m.name + ";");
		}

		stream->WriteLine("		}");
		stream->WriteLine("	}");
	}
	stream->WriteLine("	return true;");
	stream->WriteLine("}");*/

	//SetFileMode(path_to_src + componentsystemcpp, 33206);

	if (!stream->data->Save(path_to_src + componentsystemcpp))
	{
		Print("Error: Failed to write file \"" + path_to_src + componentsystemcpp + "\"");
		return 1;
	}

	//SetFileMode(path_to_src + componentsystemcpp, 4);

	return 0;
}

const bool IsFlagSet(nlohmann::json& j3)
{
	return (!j3.is_null() && j3.is_boolean());
}

const WString GetStringArg(nlohmann::json& j3, const WString& defaultval = "")
{
	if (!j3.is_null())
	{
		return JSONGetString(j3);
	}

	return defaultval;
}

int DisplayHelp()
{
	Print("Application built: " + String(__DATE__) + " at: " + String(__TIME__) + "\n");
	Print("Usage: \n===========");
	Print("Run this program in the pre-build step of the compiling process.\nThis will automatically generated files for the Ultra Engine Entity Component System relative to the project file.");
#if defined (_WIN32)
	Print("\n\tExample: path/to/tools/preprocessor.exe [outputname] [srcdir] [componentdir]\n");
#else
	Print("\n\tExample: path/to/tools/preprocessor [outputname] [srcdir] [componentdir]\n");
#endif
	Print("Arguments: \n===========");
	Print("\t+componentdir : Defines the path of the components directory relative to [srcdir].\n\t\tUsage: +componentdir <dir> (Default: Components/)\n");
	Print("\t+outputname : Defines the name of the generated header and code files.\n\t\tUsage: +outputname <filename> (Default: ComponentSystem)\n");
	Print("\t+pchfile : Defines the pch file to be written to the top of each file.\n\t\tUsage: +pchfile <filename> (Default: UltraEngine.h)\n");
	Print("\t+srcdir : Defines the path of the source directory relative to your project file.\n\t\tUsage: +srcdir <dir> (Default: Source/)\n");
	Print("Flags: \n===========");
	Print("\t-forcebuild : When set, this will cause the pre-processor to rebuild the file regardless of conditions.\n");
	Print("\t-help : Displays application build date and time along with all arguments.\n");
	Print("Notes: \n===========");
	Print("A trailing slash for any path arguments isn't required.\nThe preprocessor will automatically add a trailing slash to the end of the parameter given.\nIf \"pchfile""\" is given a custom parameter, it will be auto corrected to ensure that any paths stripped and the.h extention is present.\n");
	return 0;
}

int main(int argc, const char* argv[])
{
	//Print app information.
	Print("Ultra Engine Pre-Processor - (" + WString(__DATE__) + ")");
	auto args = ParseCommandLine(argc, argv);

	// 230102 - reep: TODO: Figure out a safe way so if the user just clicks on the application, this informaiton auto displays.
	//If -help is set, just display the help information and abort.
	if (IsFlagSet(args["help"])) return DisplayHelp();

	//User paths
	WString user_src_dir = GetStringArg(args["srcdir"], "Source/");
	WString user_component_dir = GetStringArg(args["componentdir"], "Components/");
	WString user_componentfile = GetStringArg(args["outputname"], "ComponentSystem");

	auto defaultpch = pchfile;
	pchfile = GetStringArg(args["pchfile"], defaultpch).ToString();

	// If it's not the default, make sure it's correctly set.
	if (pchfile != defaultpch)
	{
		pchfile = StripAll(pchfile);
		pchfile = pchfile + ".h";
	}

	// If empty, fill with defaults.
	if (user_src_dir.empty()) user_src_dir = "Source/";
	if (user_component_dir.empty()) user_component_dir = "Components/";

	//Check to see if there's a trailing backslash for these paths. If there isn't one, correct them!
	if (user_src_dir.Right(1) != "/") user_src_dir = user_src_dir + "/";
	if (user_component_dir.Right(1) != "/") user_component_dir = user_component_dir + "/";

	// Rebuild checks:
	if (!IsFlagSet(args["forcebuild"]))
	{
		//If the files don't exist, or if one of them is missing, force a rebuild.
		if (FileType(user_src_dir + user_componentfile + ".h") == 0 or FileType(user_src_dir + user_componentfile + ".cpp") == 0)
		{
			Print("Generating Component System files....");
			rebuild = true;
		}

		//Create the directory if it doesn't exist.
		if (FileType(user_src_dir + user_component_dir) != 2)
		{
			if (!CreateDir(user_src_dir))
			{
				Print("Error: Failed to create directory \"" + user_src_dir + "\"!");
				return DisplayHelp();
			}
		}

		// Store the file time of the header file..
		headertime = FileTime(user_src_dir + user_componentfile + ".h");
		headertime = min(headertime, FileTime(user_src_dir + user_componentfile + ".h"));

		//Compare it with the time of this application.
		//If this application is newer, force a rebuild. 
		if (FileTime(WString(argv[0])) > headertime && !rebuild)
		{
			Print("Regenerating Component System files as the pre-processor has been updated since last generation.");
			rebuild = true;
		}

		// 230118 - reep: Do one more check to see if the header and cpp file have the same time stamp
		if (!rebuild)
		{
			if (FileType(user_src_dir + user_componentfile + ".cpp") != 0 && FileType(user_src_dir + user_componentfile + ".cpp"))
			{
				WString cpp_commentheader = "";
				auto cpp_stream = ReadFile(user_src_dir + user_componentfile + ".cpp");
				if (cpp_stream != NULL) cpp_commentheader = cpp_stream->ReadLine();

				WString h_commentheader = "";
				auto h_stream = ReadFile(user_src_dir + user_componentfile + ".h");
				if (h_stream != NULL) h_commentheader = h_stream->ReadLine();

				if (cpp_commentheader.empty() || h_commentheader.empty())
				{
					// If both lines are null, trip the rebuild flag.
					Print("Regenerating Component System files as ether header information is null.");
					rebuild = true;
				}
				else if (cpp_commentheader != h_commentheader)
				{
					// If the first line of both the header file and cpp file don't match. trip the rebuild flag.
					Print("Regenerating Component System files as the header information on both files do not match.");
					rebuild = true;
				}
			}
		}
	}
	else
	{
		Print("Regenerating Component System files as -forcebuild is set.");
		rebuild = true;
	}

	//Start processing...
	auto tm = Millisecs();
	int result = 1; //Set it up for failure.
	generation_time = GenerationTimestamp();
	ProcessDir("", user_src_dir + user_component_dir);
	result = WriteHeaders(user_src_dir, user_componentfile);
	if (result == 0 && rebuild) Print("Pre-processor completed successfully - Time Elapsed: " + String(Millisecs() - tm) + " milliseconds.");
	return result;
}